# *
# *  Copyright (C) 2012-2014 Garrett Brown
# *
# *  This Program is free software; you can redistribute it and/or modify
# *  it under the terms of the GNU General Public License as published by
# *  the Free Software Foundation; either version 2, or (at your option)
# *  any later version.
# *
# *  This Program is distributed in the hope that it will be useful,
# *  but WITHOUT ANY WARRANTY; without even the implied warranty of
# *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# *  GNU General Public License for more details.
# *
# *  You should have received a copy of the GNU General Public License
# *  along with XBMC; see the file COPYING.  If not, write to
# *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
# *  http://www.gnu.org/copyleft/gpl.html
# *

import unittest

INFO_EXTENSION = '.info'

class LibretroInfo:
    """
    Info files are files that contain key-value pairs defining properties of
    binaries generated by the libretro-super build scripts. After libretro-super
    is cloned, they reside in /libretro-super/dist/info. 
    """
    
    @staticmethod
    def GetInfoExtension():
        """
        The file names of info files end in .info
        """
        return INFO_EXTENSION
    
    @staticmethod
    def _IsTrue(value):
        """
        If the key requires a boolean value, the value must be one of these strings
        to be considered True. Otherwise, the value becomes False.
        """
        return value in ['true', 'yes', '1']
    
    def __init__(self, path):
        """
        Parse a libretro .info file into a python struct. path specifies the file
        path to the info file, including the filename
        """
        self._path = path
        self._LoadDefaults()
        
        # Load file
        lines = []
        try:
            with open(path) as f:
                lines = f.read().splitlines(False) # Don't keep line endings
        except:
            return # IsValid() will return false 
        
        # Parse file
        lineCount = 0
        for line in lines:
            bool 
            # Extract name and value
            if not line or line[0] == '#': # ignore comments and empty lines
                continue
            parts = line.partition('=')
            if len(parts) != 3:
                continue
            name = parts[0].strip()
            value = parts[2].strip()
            if not name or not value:
                continue
            
            # Strip quotes from value
            if value[0] == '"' or value[0] == "'":
                value = value[1:]
            if value[-1] == '"' or value[-1] == "'":
                value = value[:-1]
            
            self._Set(name, value)
            
            lineCount += 1
        
        # Valid if we found at least 1 valid line
        self._isValid = (lineCount > 0)
    
    def _LoadDefaults(self):
        self._isValid        = False
        self._displayName    = ''
        self._displayVersion = ''
        self._description    = ''
        self._authors        = ''
        self._extensions     = ''
        self._coreName       = ''
        self._manufacturer   = ''
        self._systemName     = ''
        self._license        = ''
        self._perissions     = ''
        self._needFullpath   = False
        self._supportsNoGame = False
        self._blockExtract   = False
    
    def IsValid(self):
        return self._isValid
    
    def _Set(self, name, value):
        if   name == 'display_name':         self._displayName = value
        elif name == 'display_version':      self._displayVersion = value
        elif name == 'description':          self._description = value
        elif name == 'authors':              self._authors = value
        elif name == 'supported_extensions': self._extensions = value
        elif name == 'corename':             self._coreName = value
        elif name == 'manufacturer':         self._manufacturer = value
        elif name == 'systemname':           self._systemName = value
        elif name == 'license':              self._license = value
        elif name == 'permissions':          self._perissions = value
        elif name == 'need_fullpath':        self._needFullpath = LibretroInfo._IsTrue(value)
        elif name == 'supports_no_game':     self._supportsNoGame = LibretroInfo._IsTrue(value)
        elif name == 'block_extract':        self._blockExtract = LibretroInfo._IsTrue(value)
    
    def GetDisplayName(self):     return self._displayName
    def GetDisplayVersion(self):  return self._displayVersion
    def GetDescription(self):     return self._description
    def GetAuthors(self):         return self._authors
    def GetExtensions(self):      return self._extensions
    def GetCoreName(self):        return self._coreName
    def GetManufacturer(self):    return self._manufacturer
    def GetSystemName(self):      return self._systemName
    def GetLicense(self):         return self._license
    def GetPermissions(self):     return self._perissions
    """
    Libretro cores can't resolve the various protocols used by XBMC's VFS (like
    zip://... and special://...). The libretro API allows cores to load files
    via memory instead of file path, so XBMC can slurp the entire file's data
    into memory and pass that memory block to the client. If the libretro core
    doesn't support loading via memory (and requires an absolute path), then the
    VFS can't be used.
    """
    def SupportsVfs(self):        return 'true' if not self._needFullpath else 'false'
    def SupportsNoGame(self):     return 'true' if self._supportsNoGame else 'false'
    def ShouldBlockExtract(self): return 'true' if self._blockExtract else 'false'

class TestLibretroInfo(unittest.TestCase):
    def setUp(self):
        pass
    
    def test_libretro_info(self):
        from libretro_super import LibretroSuper
        libretroSuper = LibretroSuper()
        
        dlls = libretroSuper.GetDlls()
        self.assertNotEqual(len(dlls), 0)
        
        for dll in dlls:
            # GetDlls() only returns valid DLLs, but we can check anyway
            self.assertTrue(dll.IsValid())
            
            info = dll.GetInfo()
            self.assertTrue(info.IsValid())
            
            print('Loaded info for %s (%s)' % (info.GetDisplayName(), info.GetDisplayVersion()))

if __name__ == '__main__':
    unittest.main()
